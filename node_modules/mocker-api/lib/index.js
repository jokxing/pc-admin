"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const toRegexp = __importStar(require("path-to-regexp"));
const clear_module_1 = __importDefault(require("clear-module"));
const chokidar_1 = __importDefault(require("chokidar"));
const safe_1 = __importDefault(require("colors-cli/safe"));
const proxyHandle_1 = require("./proxyHandle");
const mockerHandle_1 = require("./mockerHandle");
__exportStar(require("./delay"), exports);
__exportStar(require("./utils"), exports);
const pathToRegexp = toRegexp.pathToRegexp;
let mocker = {};
module.exports = mockerApi;
function mockerApi(app, watchFile, conf = {}) {
    const watchFiles = (Array.isArray(watchFile) ? watchFile : typeof watchFile === 'string' ? [watchFile] : []).map(str => path_1.default.resolve(str));
    if (watchFiles.some(file => !file)) {
        throw new Error('Mocker file does not exist!.');
    }
    /**
     * Mybe watch file or pass parameters
     * https://github.com/jaywcjlove/mocker-api/issues/116
     */
    const isWatchFilePath = (Array.isArray(watchFile) && watchFile.every(val => typeof val === 'string')) || typeof watchFile === 'string';
    mocker = isWatchFilePath ? getConfig() : watchFile;
    if (!mocker) {
        return (req, res, next) => {
            next();
        };
    }
    let options = { ...conf, ...(mocker._proxy || {}) };
    const defaultOptions = {
        changeHost: true,
        pathRewrite: {},
        proxy: {},
        // proxy: proxyConf: {},
        httpProxy: {},
        // httpProxy: httpProxyConf: {},
        bodyParserConf: {},
        bodyParserJSON: {},
        bodyParserText: {},
        bodyParserRaw: {},
        bodyParserUrlencoded: {},
        watchOptions: {},
        header: {},
        priority: 'proxy',
        withFullUrlPath: false
    };
    options = { ...defaultOptions, ...options };
    // changeHost = true,
    // pathRewrite = {},
    // proxy: proxyConf = {},
    // httpProxy: httpProxyConf = {},
    // bodyParserConf= {},
    // bodyParserJSON = {},
    // bodyParserText = {},
    // bodyParserRaw = {},
    // bodyParserUrlencoded = {},
    // watchOptions = {},
    // header = {}
    if (isWatchFilePath) {
        // 监听配置入口文件所在的目录，一般为认为在配置文件/mock 目录下的所有文件
        // 加上require.resolve，保证 `./mock/`能够找到`./mock/index.js`，要不然就要监控到上一级目录了
        const watcher = chokidar_1.default.watch(watchFiles.map(watchFile => path_1.default.dirname(require.resolve(watchFile))), options.watchOptions);
        watcher.on('all', (event, path) => {
            if (event === 'change' || event === 'add') {
                try {
                    // 当监听的可能是多个配置文件时，需要清理掉更新文件以及入口文件的缓存，重新获取
                    cleanCache(path);
                    watchFiles.forEach(file => cleanCache(file));
                    mocker = getConfig();
                    if (mocker._proxy) {
                        options = { ...options, ...mocker._proxy };
                    }
                    console.log(`${safe_1.default.green_b.black(' Done: ')} Hot Mocker ${safe_1.default.green(path.replace(process.cwd(), ''))} file replacement success!`);
                }
                catch (ex) {
                    console.error(`${safe_1.default.red_b.black(' Failed: ')} Hot Mocker ${safe_1.default.red(path.replace(process.cwd(), ''))} file replacement failed!!`);
                }
            }
        });
    }
    // 监听文件修改重新加载代码
    // 配置热更新
    app.all('/*', (req, res, next) => {
        const getExecUrlPath = (req) => {
            return options.withFullUrlPath ? req.url : req.path;
        };
        /**
         * Get Proxy key
         */
        const proxyKey = Object.keys(options.proxy).find((kname) => {
            return !!pathToRegexp(kname.replace((new RegExp('^' + req.method + ' ')), '')).exec(getExecUrlPath(req));
        });
        /**
         * Get Mocker key
         * => `GET /api/:owner/:repo/raw/:ref`
         * => `GET /api/:owner/:repo/raw/:ref/(.*)`
         */
        const mockerKey = Object.keys(mocker).find((kname) => {
            return !!pathToRegexp(kname.replace((new RegExp('^' + req.method + ' ')), '')).exec(getExecUrlPath(req));
        });
        /**
         * Access Control Allow options.
         * https://github.com/jaywcjlove/mocker-api/issues/61
         */
        const accessOptions = {
            'Access-Control-Allow-Origin': req.get('Origin') || '*',
            'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE',
            'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With,' + (req.header('access-control-request-headers') || ''),
            'Access-Control-Allow-Credentials': 'true',
            ...options.header,
        };
        Object.keys(accessOptions).forEach(keyName => {
            res.setHeader(keyName, accessOptions[keyName]);
        });
        // fix issue 34 https://github.com/jaywcjlove/mocker-api/issues/34
        // In some cross-origin http request, the browser will send the preflighted options request before sending the request methods written in the code.
        if (!mockerKey && req.method.toLocaleUpperCase() === 'OPTIONS'
            && Object.keys(mocker).find((kname) => !!pathToRegexp(kname.replace((new RegExp('^(PUT|POST|GET|DELETE) ')), '')).exec(getExecUrlPath(req)))) {
            return res.sendStatus(200);
        }
        /**
         * priority 'proxy' or 'mocker' [#151](https://github.com/jaywcjlove/mocker-api/issues/151)
         */
        if (options.priority === 'mocker') {
            if (mocker[mockerKey]) {
                return (0, mockerHandle_1.mockerHandle)({ req, res, next, mocker, options, mockerKey });
            }
            else if (proxyKey && options.proxy[proxyKey]) {
                return (0, proxyHandle_1.proxyHandle)(req, res, options, proxyKey);
            }
        }
        else {
            if (proxyKey && options.proxy[proxyKey]) {
                return (0, proxyHandle_1.proxyHandle)(req, res, options, proxyKey);
            }
            else if (mocker[mockerKey]) {
                return (0, mockerHandle_1.mockerHandle)({ req, res, next, mocker, options, mockerKey });
            }
        }
        next();
    });
    /**
     * The old module's resources to be released.
     * @param modulePath
     */
    function cleanCache(modulePath) {
        // The entry file does not have a .js suffix,
        // causing the module's resources not to be released.
        // https://github.com/jaywcjlove/webpack-api-mocker/issues/30
        try {
            modulePath = require.resolve(modulePath);
        }
        catch (e) { }
        var module = require.cache[modulePath];
        if (!module)
            return;
        // remove reference in module.parent
        if (module.parent) {
            module.parent.children.splice(module.parent.children.indexOf(module), 1);
        }
        // https://github.com/jaywcjlove/mocker-api/issues/42
        (0, clear_module_1.default)(modulePath);
    }
    /**
     * Merge multiple Mockers
     */
    function getConfig() {
        return watchFiles.reduce((mocker, file) => {
            const mockerItem = require(file);
            return Object.assign(mocker, mockerItem.default ? mockerItem.default : mockerItem);
        }, {});
    }
    return (req, res, next) => {
        next();
    };
}
exports.default = mockerApi;
//# sourceMappingURL=index.js.map